# Algorithm

알고리즘을 공부하기 위한 저장소입니다.

[자바](https://github.com/OhYeHwan/Algorithm/tree/main/java/src),
[자바스크립트](https://github.com/OhYeHwan/Algorithm/tree/main/javascript),
[파이썬](https://github.com/OhYeHwan/Algorithm/tree/main/python) 을 이용합니다.

## 간단 정리

### 0. 복잡도

#### 시간 복잡도

```
- 알고리즘 문제풀이에서 단순히 '복잡도'라고 하면 보통은 시간 복잡도를 의미
- 시간 복잡도란 프로그램(알고리즘)이 특정한 크기의 입력을 받아 이를 처리하고 실행 결과를 출력하는데 까지 걸리는 시간을 의미
- 시간 복잡도를 표현할 때는 빅오 표기법 사용
- 연산 횟수 10억의 경우 : 1초 이상의 시간 소요(C언어 기준)
```

##### 빅오 표기법이란 : 함수의 상한만을 나타낸다 (N은 데이터의 개수)

| 빅오 표기법 | 명칭           |
| ----------- | -------------- |
| O(1)        | 상수 시간      |
| O(logN)     | 로그 시간      |
| O(N)        | 선형 시간      |
| O(NlogN)    | 로그 선형 시간 |
| O(N^2)      | 이차 시간      |
| O(N^3)      | 삼차 시간      |
| O(2^n)      | 지수 시간      |

##### 시간 제한 1초인 문제에 대한 예시

| N의 범위   | 시간 복잡도 |
| ---------- | ----------- |
| 500        | O(N^3)      |
| 2,000      | O(N^2)      |
| 100,000    | O(NlogN)    |
| 10,000,000 | O(N)        |

### 1. Greedy (탐욕법)

```
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 현재의 선택이 나중에 미칠 영향에 대해서 고려하지 않음
- 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 *기준*을 제시
- 문제 해결 후에 해법이 정당한지 검토가 필요

* 오름차순, 내림차순으로 정렬 후 문제 풀이
```

### 2. 구현

```
- 알고리즘을 소스코드로 바꾸는 과정
- 문제에 대한 정확한 풀이 방법을 프로그래밍 언어로 구현하는 것
- 프로그래밍 언어의 문법을 정확히 알고 문제의 요구사항을 정확히 파악하는 것이 중요
- 완전탐색 : 모든 경우의 수를 전부 계산하는 해결 방법
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형
- python(3.7) : 1초에 2000만번 연산 수행 => N=1,000,000 일 때 O(NlogN) 복잡도에 해당하는 알고리즘 사용 필요
```

#### C/C++/Java 정수형 종류에 따른 범위

| 정수형 종류 | 자료형 크기 | 자료형 범위                                            |
| ----------- | ----------- | ------------------------------------------------------ |
| int         | 4 Byte      | -2,147,483,648 ~ 2,147,438,647                         |
| long long   | 8 Byte      | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

<br>

#### int 자료형 데이터의 개수에 따른 메모리 사용량

| 데이터 개수 | 메모리 사용량 |
| ----------- | ------------- |
| 1,000       | 약 4KB        |
| 1,000,000   | 약 4MB        |
| 10,000,000  | 약 40MB       |

### 3. DFS/BFS

#### 자료구조 기초

```
- 탐색 : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
- 그래프, 트리와 같은 자료구조 안에서 탐색하는 것을 다룬다.
- DFS/BFS는 대표적인 탐색 알고리즘
- DFS/BFS를 이해하기 위해서는 스택과 큐 자료구조를 이해해야 한다.
- 자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조
- 스택 : 선입후출 (프링글스 통)
    - append(), pop()
- 큐 : 선입선출 (대기줄)
    - from collections import deque
    - append(), popleft()
- 재귀함수 : 자기 자신을 다시 호출하는 함수
    - 종료 조건 필수
```

#### DFS

```
- Depth-First Search
- 깊이 우선 탐색 : 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 또는 재귀함수 이용
- 그래프 : 노드와 간선으로 표현. 크게 2가지 방식으로 표현
    - 인접 행렬
    - 인접 리스트

- 동작 원리
    1. 탐색 시작 노드를 스택에 삽입 & 방문 처리
    2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 해당 인접 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없다면 스택에서 최상노드를 꺼낸다.
    3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복
```

#### BFS

```
- Breadth First Search
- 너비 우선 탐색 : 가까운 노드부터 탐색
- 큐 이용

- 동작 원리
    1. 탐색 시작 노드를 큐에 넣고 방문 처리
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
    3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복
```
